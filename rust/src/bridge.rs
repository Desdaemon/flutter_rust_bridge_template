// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.9.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!();

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_platform_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "platform",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco((move || Result::<_, ()>::Ok(crate::api::entry::platform()))())
        },
    )
}
fn wire_rust_release_mode_impl() -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rust_release_mode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            transform_result_dco((move || {
                Result::<_, ()>::Ok(crate::api::entry::rust_release_mode())
            })())
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<i32> for i32 {
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::entry::Platform> for i32 {
    fn cst_decode(self) -> crate::api::entry::Platform {
        match self {
            0 => crate::api::entry::Platform::Unknown,
            1 => crate::api::entry::Platform::Android,
            2 => crate::api::entry::Platform::Ios,
            3 => crate::api::entry::Platform::Windows,
            4 => crate::api::entry::Platform::Unix,
            5 => crate::api::entry::Platform::MacIntel,
            6 => crate::api::entry::Platform::MacApple,
            7 => crate::api::entry::Platform::Wasm,
            _ => unreachable!("Invalid variant for Platform: {}", self),
        }
    }
}
impl SseDecode for bool {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for i32 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::entry::Platform {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::entry::Platform::Unknown,
            1 => crate::api::entry::Platform::Android,
            2 => crate::api::entry::Platform::Ios,
            3 => crate::api::entry::Platform::Windows,
            4 => crate::api::entry::Platform::Unix,
            5 => crate::api::entry::Platform::MacIntel,
            6 => crate::api::entry::Platform::MacApple,
            7 => crate::api::entry::Platform::Wasm,
            _ => unreachable!("Invalid variant for Platform: {}", inner),
        };
    }
}

impl SseDecode for () {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

// Section: rust2dart

impl flutter_rust_bridge::IntoDart for crate::api::entry::Platform {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0,
            Self::Android => 1,
            Self::Ios => 2,
            Self::Windows => 3,
            Self::Unix => 4,
            Self::MacIntel => 5,
            Self::MacApple => 6,
            Self::Wasm => 7,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::entry::Platform {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::entry::Platform>
    for crate::api::entry::Platform
{
    fn into_into_dart(self) -> crate::api::entry::Platform {
        self
    }
}

impl SseEncode for bool {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for i32 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::entry::Platform {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for () {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

#[cfg(not(target_family = "wasm"))]
#[path = "bridge.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "bridge.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
